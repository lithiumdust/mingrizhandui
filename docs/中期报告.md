# 一.机器人的运动
## 1.PWM

 最初，我先学习c语言，为掌握stm32做准备，在完成基础的学习后，我着手驱动马达这第一个目标。
  首先我学习焊接知识，把导线焊在马达上。
 然后我学习电机驱动模块l298n的使用方法。
 这时我意识到要去学习pwm的知识，所以我开始学习pwm，我了解到要调节占空比来控制马达转速。
 于是就写了下面的代码：
  ```
 void TIM3_PWM_Init(void)
 {  
 //	GPIO_InitTypeDef GPIO_InitStructure;
 //	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
 //	TIM_OCInitTypeDef  TIM_OCInitStructure;
 //	
 //	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	//使能定时器3时钟
 // 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);  //使能GPIO外设；
 //	
 //	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射  TIM3_CH2->PB5    
 // 
 //   //初始化输出TIM3四个通道PWM脉冲波形的引脚(CH1->PA6 CH2->PA7)
 //	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_5|GPIO_Pin_4|GPIO_Pin_1; //TIM_CH1、CH2
 //	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出
 //	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 //	GPIO_Init(GPIOB, &GPIO_InitStructure);//初始化GPIO
 // 
 //   //初始化TIM3
 //	TIM_TimeBaseStructure.TIM_Period = 7199; //设置在下一个更新事件装入活动的自 动  
 重装载寄存器周期的值
 //	TIM_TimeBaseStructure.TIM_Prescaler =0; //设置用来作为TIMx时钟频率除数的预分 频值 
 //	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
 //	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
//	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
//	
//	//初始化TIM3 Channe12 PWM模式	 
//	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //选择定时器模式:TIM脉冲宽度调制模式1
// 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
//	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高
//	
//	TIM_OC1Init(TIM3, &TIM_OCInitStructure); 
//	TIM_OC2Init(TIM3, &TIM_OCInitStructure); 
//	TIM_OC3Init(TIM3, &TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC1
//  TIM_OC4Init(TIM3, &TIM_OCInitStructure);
//	
//	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable); 
//	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable); 
//	TIM_OC3PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIM3在CCR1上的预装载寄存器
//  TIM_OC4PreloadConfig(TIM3, TIM_OCPreload_Enable);
//	
//	TIM_Cmd(TIM3, ENABLE);  //使能TIM 3
}
```
## 2.电机驱动模块
在硬件连接阶段，我研究L298N的引脚定义，将STM32的PA0、PA1引脚配置为GPIO输出，用于控制电机的转向；PA2引脚配置为PWM输出，用于调节电机转速。同时，将L298N的电源端与STM32的电源模块连接，确保供电稳定。
```
void Motor_Init()
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7|GPIO_Pin_8;  //依次接L298N  IN1,IN2,IN3,IN4
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
}
```
 

## 3.ps2手柄控制电机
现在只要我上电源，马达就可以转了，但是不能控制什么时候转，于是我学习ps2手柄怎么用。
刚开始接触PS2手柄时，我先查阅了其通信协议文档，了解到PS2手柄采用SPI通信（或类SPI的同步串行通信），通过DATA、CMD、CS、CLK四根信号线与STM32进行数据交互，每次通信会返回16字节的按键/摇杆数据。为了验证通信可行性，我先在面包板上搭建了最小测试电路：将PS2手柄的DATA接STM32F103的PB14（SPI2_MISO）、CMD接PB15（SPI2_MOSI）、CS接PB12（GPIO输出）、CLK接PB13（SPI2_SCK），同时给手柄供电（3.3V）。部分代码如下
```
unsigned int Handkey;	// 按键值读取，零时存储。
//uint8_t Key_num;
uint8_t ps2_mode;
uint8_t Comd[9]={0x01,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00};	//开始命令。请求数据
uint8_t Data[9]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; //数据存储数组
uint8_t key_search[12] = {0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00,
						  0x00,0x00,0x00,0x00};

unsigned int MASK[16][2]={
    {PSB_SELECT,0},
    {PSB_L3,0},
    {PSB_R3,0},
    {PSB_START,0},
    {PSB_PAD_UP,0},
    {PSB_PAD_RIGHT,0},
    {PSB_PAD_DOWN,0},
    {PSB_PAD_LEFT,0},
    {PSB_L2,0},
    {PSB_R2,0},
    {PSB_L1,0},
    {PSB_R1 ,0},
    {PSB_GREEN,0},
    {PSB_RED,0},
    {PSB_BLUE,0},
    {PSB_PINK,0}
	};	//按键值与按键明

void PS2_Init(void)
{ 	
	PS2_GPIO_Init();
	
	PS2_SCK_H();
	PS2_CS_H();
	PS2_ShortPoll();
	PS2_ShortPoll();
	PS2_ShortPoll();
	PS2_EnterConfing();		//进入配置模式
	PS2_TurnOnAnalogMode();	//“红绿灯”配置模式，并选择是否保存
	//PS2_VibrationMode();	//开启震动模式
	PS2_ExitConfing();		//完成并保存配置 
	ps2_mode_get();
}

//向手柄发送命令
unsigned char PS2_Cmd(unsigned char CMD)
{    
	unsigned char i,j=1;
	unsigned char res=0; 
	for(i=0;i<=7;i++)     //逐位接收     
	{
		 if(CMD&0x01)
			PS2_DO_H();  
		 else
			PS2_DO_L();  
		 
		 CMD=CMD>>1;
		 
		 PS2_Delay_US(100);
		 PS2_SCK_L();   	
		 PS2_Delay_US(100);
		 
		 if(PS2_DI()) 
		 {
			res=res+j;
		 }
		 j=j<<1;
		
		 PS2_SCK_H();   
		 PS2_Delay_US(1);		 
	}

	return res;	
}

//读取手柄数据
void PS2_ReadData(void)
{
	unsigned char byte=0;
	PS2_CS_L();
    PS2_Delay_US(10);

    for(byte = 0; byte < 9; byte++)
    {
        if(byte < 2)
        {
            Data[byte] = PS2_Cmd(Comd[byte]);
        }
        else
        {
            Data[byte] = PS2_Cmd(0x00);
        }
    }
	PS2_CS_H();
	PS2_Delay_US(10);
```
 ## 4.麦轮及机器人各方向运动
 硬件安装是麦轮驱动的基础，也是最容易出问题的环节。按“前左-45°、前右-135°、后左-135°、后右-45°”的标准布局安装（确保辊子夹角对称），每个麦轮对应一个L298N驱动模块，分别由STM32F103的PB0-PB3引脚控制转向，PC0-PC3引脚输出PWM调节转速。但首次安装后，小车不仅无法横移，还出现“原地打转”的情况——排查后发现，前右麦轮的辊子夹角装反了（误装为45°），导致受力方向冲突。这次失误让我意识到，麦轮的安装精度直接决定运动效果，并用记号笔标注电机正反转方向，避免装反。小车各方向运动代码如下。
 ```	if (PS2_Mode != Last_PS2_Mode)
		{
			Set_Car_Speed1(0,0);
			Set_Car_Speed2(0,0);
		}
		   
		if (PS2_Mode == PSB_REDLIGHT_MODE)
		
			unsigned char ps2_lx,ps2_ly,ps2_rx,ps2_ry;
			
			ps2_lx = ps2_get_anolog_data(PSS_LX);
			ps2_ly = ps2_get_anolog_data(PSS_LY);
			
			if ( ps2_ly == 0x00)
			{
			
					Set_Car_Speed1(-7200,-7200);
				Set_Car_Speed2(-7200,-7200);
				
				GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
			}
			else if (ps2_ly == 0xff)
			{
			
						Set_Car_Speed2(7200,7200);
				Set_Car_Speed1(7200,7200);
				GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
			}
			else if (ps2_lx == 0x00)
			{
			
						Set_Car_Speed1(7200,7200);
					Set_Car_Speed2(-7200,-7200);
				GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
			}
			else if (ps2_lx == 0xff)
			{	Set_Car_Speed1(-7200,-7200);
					Set_Car_Speed2(7200,7200);
		
				GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
			}
			else
			{
				if (ps2_get_key_state(PSB_L1))
				{
					Set_Car_Speed1(7200,-7200);
					Set_Car_Speed2(-7200,7200);
					GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
				}
				else if (ps2_get_key_state(PSB_L2))
				{
					Set_Car_Speed1(-7200,7200);
					Set_Car_Speed2(7200,-7200);
					GPIO_WriteBit(GPIOC,GPIO_Pin_13,Bit_SET);
				}				
				else
				{
					Set_Car_Speed1(0,0);
					Set_Car_Speed2(0,0);
				}			
			}
```
至此，小车可以全向运动了。
下一步我们研究怎么收集小球。
# 二.收集小球
## 1.舵机
收集小球要用舵机，所以我们先学习舵机的使用,下面是舵机初始化代码
```
void Servo_Time_Init()
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	
	TIM_InternalClockConfig(TIM1);
	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;
	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;
	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInitStructure.TIM_Period = 10-1;
	TIM_TimeBaseInitStructure.TIM_Prescaler = 72 - 1;
	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;
	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStructure);
	
	TIM_ClearFlag(TIM1, TIM_FLAG_Update);
	TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);

	NVIC_InitTypeDef NVIC_InitStructure;
	NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
	NVIC_Init(&NVIC_InitStructure);
	
	TIM_Cmd(TIM1, ENABLE);
}
```
接着我们要调节占空比来让舵机转到特定角度，代码如下：
```
void RobotArm_RaiseHand(uint8_t unit_pwm)
{
	unit_pwm = robotarm_left.pwm + unit_pwm;
	Robot_LeftPwm_Set(unit_pwm);
}
void Robot_LeftPwm_Set(uint16_t value)
{
	//限幅
	if (value < robotarm_left.left_limit)
	{
		value = robotarm_left.left_limit;
	}
	else if (value > robotarm_left.right_limit)
	{
		value = robotarm_left.right_limit;
	}
	
	robotarm_left.pwm = value;
}
```
## 2.最初方案
，我们最初的想法是建一个大铲子收集小球（二号机器人），然后用舵机把铲子抬高，最后反转铲子，把球装到一号机器人里。打印共三个零件，分别为舵机固定支架，收集铲斗及连接件。利用MG995与SG90舵机控制铲斗的运动。实际测试后发现由于机器人的尺寸要求，铲斗的大小受到限制，收集弹丸的效率实际较低；结构运动自由度较低，控制收集运动操作过于繁琐，在实际比赛时稳定性较差，易出现操作失误。并且铲子太厚了，铲不起来球，只会把球推着走，故对现有方案进行修改。
## 3.后期方案
收集结构后改为滚刷收集，利用电机驱动滚刷转动。打印共两个零件，分别为舵机固定支架与滚刷固定件，舵机固定支架将SG90舵机固定于底盘，舵机直接利用配套固定件与滚刷固定结构相连。滚刷固定件除预留用于固定滚刷与电机的结构外，设计有弧形斜坡将被滚刷推动的弹丸导入弹丸携带结构。
这样一来效率就高得多了。
# 三.携带小球
## 1.fusion
为了3d打印，我们学习了建模，所以我们从fusion开始，学习了基本的fusion知识
## 2.3d打印
后来我参加了统一培训，会用打印机了。
## 3.初期方案
一开始我们想建一个大方斗来装载小球（一号机器人），可是打印出来发现斗太大了，不满足规定，而且空间利用率低下，可以装的小球太少了，于是我们换了一个方案。
## 4.后期方案
为尽可能降低打印件重量及大小对机器人运行速度及灵活度的影响，仅设计左右后三处围挡零件与小车底盘共同组成弹丸的携带结构。弹丸经过过滚刷固定结构上弧形斜坡引导直接落到底盘上，并由三处围挡保证弹丸能被机器人稳定携带。为减少弹丸对电路结构的影响，在后方围挡顶部设计出一块平板结构用于放置单片机等电路硬件，并在三处围挡留有孔洞用于布线，尽可能将电路结构与弹丸的携带结构分离。这样一来携带小球的空间就得到了充分运用。
# 四.聚集小球
如前文所述，我们一开始想用一号机器人携带小球，二号机器人收集小球，可是这样效率低下，所以我们最终更改了机器人的分工，让一号机器人承担收集和携带小球的任务（前文已充分交代），二号机器人聚集小球。
所以在二号机器人的前方，有一个聚拢小球的无底推铲，检查时推铲抬起，确保尺寸合规。以下是控制推铲的舵机的部分代码
```
	//机械臂控制
			ps2_rx = ps2_get_anolog_data(PSS_RX);
			if (ps2_rx == 0xFF)
			{
				RobotArm_RaiseHand(UNIT_PWM);
			}
			else if (ps2_rx == 0x00)
			{
				RobotArm_DropHand(UNIT_PWM);
			}
```
二号机器人的运动代码和前文基本一样，故不再赘述。
# 五.总结
我们的两个机器人经历多次迭代，目前已经具备了携带、收集、聚集小球的功能。但在收集小球的效率问题上仍有待提高。